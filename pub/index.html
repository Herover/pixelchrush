<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="user-scalable=no, width=400, initial-scale=1, maximum-scale=1">
<script>
window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          function( callback ){
            window.setTimeout(callback, 1000 / 60);
          };
})();
</script>
<script src="/socket.io/socket.io.js"></script>
<script src="boxie.js"></script>
<style type="text/css">
  html{
    height:100%;
    font: 13px Helvetica, arial, freesans, clean, sans-serif
  }
	body{
		background-color: #000;
		color:#fff;
		margin: 0px;
		padding:0px;

    height:100%;
    overflow: hidden;
	}
  #content{
    /*margin:auto;
    width:600px;*/

    min-height: 100%;
  }
	#game,#chat{
		margin:auto;
    overflow:hidden;
	}
  #game{
		/*height:400px;
		width:400px;*/
    /*float:left;*/
  }
  #chat{
    width:200px;
    position:absolute;
    top:0px;
    max-width: 1200px;
  }/*
  @media all and (max-width: 599px) {
    #chat{
      position: absolute;
      left: 0px;

      margin: 0px;
    }
    #content{
      width: 400px;
    }
  }*/
  .sc{
    float:left;
    position:absolute;
    color:#000;
    top:0px;
  }
  #g_power{
    position:absolute;
    top:0px;
    margin:auto;
    font-size: 350%;
    max-width: 1200px;
    color: #f00;
  }
</style>
</head>
<body>
  <div id="content">
  <div id="game">
    <canvas id="can" width="400" height="400"></canvas>
    <canvas id="noise" width="400" height="400" hidden="hidden"></canvas>
    <div id="g_power" hidden="hidden"><h2>Powerup <span id="g_power_str"></span></h2><h3>Press F!</h3></div>
    <div class="sc" id="sc_startgame"><h1>Pixel Crush!</h1><input id="e_name" type="text" value="Enter Your name"/><ul><li onclick="sc_startgame()">Start game</li><li onclick="sc_showhelp()">Help</li></ul></div>
    <div class="sc" id="sc_help"><h1>Pixel Crush!</h1>
      <pre>Game:
 You are a confused circle in a weird pixelized 
 world.
 You dislike the fuzzy pixelating stuff around, 
 so to remove it you eat white cirkles.
 Unfortunally, other confused cirkles wants your
 cirkles, and tries to kill you! Push boxes on
 top of them to get rid of them.

 Controls (desktop):
  WASD or arrow keys to move
  SPACE to drag box
  F to use power

 Controls (mobile/touch):
  Touch above, under, left of, right of circle
  to move
  Touch near border of screen to drag box
  Tap on circle to use power

Made by:
 Herover!
 Also, build on Node.js, socket.io, and maybe
 something else too.</pre>
      <a onclick="sc_showmenu()">Back</a>
    </div>
  </div>
  <div id="chat">
    <p id="myname"></p>
    <ul id="messages"></ul>
  </div>
</div>
</body>

<script>
	var canvas = document.getElementById("can"),
      noise = document.getElementById("noise"),
      e_myname = document.getElementById("myname"),
      e_messages = document.getElementById("messages"),
      e_power = document.getElementById("g_power"),
      e_powerstr = document.getElementById("g_power_str"),
      e_game = document.getElementById("game"),
      touchstart,
      touch_last_ime = 0,
      touch_e = false
      net_confirm = 0;
  function addMessage(txt,color){
    var item = document.createElement("li");
    item.appendChild(item.ownerDocument.createTextNode(txt));
    item.style.setProperty("color",color);
    e_messages.insertBefore(item,e_messages.firstChild);
  }

	var game = new Boxie.Game(); 
  game.setCanvas(canvas, noise)
 
  function setupconnection(name){
    socket = io.connect();
    socket.send("connection");

    if(e_game.requestFullscreen)
      e_game.requestFullscreen();
    if(e_game.mozRequestFullScreen)
      e_game.mozRequestFullScreen();
    if(e_game.webkitRequestFullscreen)
      e_game.webkitRequestFullscreen();

    socket.on("OK",function(data){
      console.log("got OK");
      socket.emit("activate",{name:name});
      socket.on("self",function(data){
        console.log("Got self, working...");

        

        player = new Boxie.Man(data.id,data.settings);
        player.pos = data.pos;
        game.addObject(player);
        
        e_myname.innerHTML = data.settings.name;
        var col = data.settings.color;
        e_myname.style.setProperty("color","rgb("+col[0]+","+col[1]+","+col[2]+")");

        var pushmode = true; //Should player drag objects?

        player.listen("move",function(data){
          socket.emit("move",data);
          net_confirm++;
          //console.log("move",data);
        });
        socket.on("move", function(data){
          if(net_confirm>5){
            player.pos = data;
            net_confirm = 0;
            console.log("CONFIRM 5!");
            socket.emit("game");
            socket.emit("objects");
          }
          else
            net_confirm--;
          if(net_confirm==0){
            player.pos = data;
            socket.emit("hash");
          }
          console.log("confirm",net_confirm);
        })
        player.listen("die", function(data){
          socket.emit("respawn");
        });
        socket.on("game",function(data){
          console.log("Got game, working");
          game.world = data.world;
        });
        socket.on("hash",function(data){
          console.log("hash",game.hash(),data);
          if(game.hash() != data){
            socket.emit("game");
            socket.emit("objects");
            console.log("data mishmatch");
          }
        });
        socket.on("pl",function(data){
          console.log("Got playerlist, working");
          for(var id in data){
            if(typeof game.objects[id]=="undefined"){
              var o;
              if(data[id].settings.type == 1){
                o = new Boxie.Man(id,data[id].settings);
                var col = o.settings.color;
                addMessage(o.settings.name + " joined ", "rgb("+col[0]+","+col[1]+","+col[2]+")");
              }
              else if(data[id].settings.type == 2)
                o = new Boxie.Point(id,data[id].settings);
              console.log(id, o.settings, data[id].settings);
              //game.objects[id] = o;
              game.addObject(o);
              o.pos = data[id].pos;
            }else{
              game.objects[id].settings = data[id].settings;
            }
          }
          for(var i in game.objects){
            if(typeof data[game.objects[i].id] == "undefined"){
              console.log("deleting",game.objects[i].id);
              delete game.objects[game.objects[i].id];
            }
          }
        });
        socket.on("pp",function(data){
          console.log(data,game.objects[data.id].pos)
          game.objects[data.id].pos=data.pos;
        });
        socket.on("pn",function(data){
          console.log(data);
          game.objects[data.t].settings.points=data.value;
          delete game.objects[data.p];
        });
        socket.on("swapb",function(data){
          player.boxie.move(data.a,data.b);
        });
        socket.on("die",function(data){
          game.objects[data.id].die(data.reason);
          console.log(data.id, "was killed by", data.reason.player);
          var col = game.objects[data.id].settings.color;
          addMessage(game.objects[data.id].settings.name + " was killed by " + game.objects[data.reason.player].settings.name,"rgb("+col[0]+","+col[1]+","+col[2]+")");
        });
        socket.on("respawn",function(data){
          console.log("Respawning...");
          game.objects[data.id].pos=data.pos;
          game.objects[data.id].settings.dead=0;
        });
        socket.on("pwr",function(data){
          e_power.removeAttribute("hidden");
          e_powerstr.innerHTML = data;
        });
        socket.on("rotate",function(){
          game.can_rotate_to += Math.PI * 2;
        });


        window.addEventListener("keydown", function(e){
          e.preventDefault();
          switch(e.which){
            case 87://W
              player.move([0,-1],pushmode);
              break;
            case 38://W
              player.move([0,-1],pushmode);
              break;
            case 65://A
              player.move([-1,0],pushmode);
              break;
            case 37://A
              player.move([-1,0],pushmode);
              break;
            case 83://S
              player.move([0,1],pushmode);
              break;
            case 40://S
              player.move([0,1],pushmode);
              break;
            case 68://D
              player.move([1,0],pushmode);
              break;
            case 39://D
              player.move([1,0],pushmode);
              break;
            case 32: //space
              pushmode = 2;
              break;
            case 70://F
              e_power.setAttribute("hidden","hidden");
              if(player.settings.pwr!=""){
                socket.emit("pwr");
              }
            default:
              console.log(e.which);
          }
        });
        window.onkeyup = function(e){
          switch(e.keyCode){
            case 32: //space
              pushmode = true;
            default:

          }
        }
        /*
        Hammer(canvas,{swipe_velocity: 0.3}).on("swipeleft", function() {
          player.move([-1,0]);
        });
        Hammer(canvas).on("swiperight", function() {
          player.move([1,0]);
        });
        Hammer(canvas).on("swipeup", function() {
          player.move([0,-1]);
        });
        Hammer(canvas).on("swipedown", function() {
          player.move([0,1]);
        });*/

        document.body.addEventListener("touchstart", function(e){
          e.preventDefault();
          starttouch = e.changedTouches[0];
          console.log("touchdown");
          touch_e = e;

          if(
            Math.abs(e.changedTouches[0].pageX-game.settings.screen[0]/2)<game.settings.width
          &&Math.abs(e.changedTouches[0].pageY-game.settings.screen[1]/2)<game.settings.width
          ){
            e_power.setAttribute("hidden","hidden");
            if(player.settings.pwr!=""){
              socket.emit("pwr");
            }
          }

          //touchhandle(e);

        });
        document.body.addEventListener("touchend", function(e){
          e.preventDefault();

          touch_e = false;
          //touchhandle(e);

        });
        document.body.addEventListener("touchmove", function(e){
          e.preventDefault();
          touch_e = e;
          touchhandle(e);
        });
        
      });
    });
  }

  function touchhandle(){
    if(!touch_e)return 0;
    var time = new Date().getTime();
    if(touch_last_ime+50<time){
      touch_last_ime = new Date().getTime();
      /*var sX = starttouch.pageX,
          sY = starttouch.pageY,*/
      var sX = game.settings.screen[0]/2,
          sY = game.settings.screen[1]/2,
          nX = touch_e.changedTouches[0].pageX,
          nY = touch_e.changedTouches[0].pageY,
          pushmode;

      if(Math.abs(nX-sX) > Math.abs(nY-sY)){
        pushmode = (nX<game.settings.width||nX>game.settings.screen[0]-game.settings.width)?2:true;
        if(nX<sX)
          player.move([-1, 0],pushmode);
        else
          player.move([1, 0],pushmode);
      }
      else{
        pushmode = (nY<game.settings.width||nY>game.settings.screen[1]-game.settings.width)?2:true;
        if(nY<sY)
          player.move([0,-1],pushmode);
        else
          player.move([0,1],pushmode);
      }
      console.log(nX,nY,sX,sY);
      //alert(nX,nY,sX,sY)

    }
  }

  function update(){
    window.requestAnimFrame(function(){
      game.draw();
      touchhandle();
      update();
    }, canvas);
  }
  
  
  //TODO: MVC'fy or closure
  function sc_hidescreens(){
    var screens = document.getElementsByClassName("sc");
    for(var sc=0;sc<screens.length;sc++){
      screens[sc].setAttribute("hidden","hidden");
    }
  }
  function sc_showscreen(id){
    var screens = document.getElementsByClassName("sc");
    for(var sc=0;sc<screens.length;sc++){
      if(screens[sc].id == id){
        screens[sc].removeAttribute("hidden");
        console.log(screens[sc].id,"screen is showed");
      }
      else{
        screens[sc].setAttribute("hidden","hidden");
        console.log(sc,"is not the right screen");
      }
    }
    //sc_showscreen("sc_startgame");//Fallback
    //console.log("Didn't find screen with id",id);
  }
  sc_hidescreens();
  sc_showscreen("sc_startgame");
  
  function sc_startgame(){
    console.log("starting");
    sc_hidescreens();
    setupconnection(document.getElementById("e_name").value);
  }
  function sc_showhelp(){
    sc_hidescreens();
    sc_showscreen("sc_help");
  }
  function sc_showmenu(){
    sc_showscreen("sc_startgame");
  }


  function onResize(){
    game.settings.screen[0] = noise.width = canvas.width = window.innerWidth;
    game.settings.screen[1] = noise.height = canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", onResize);
  onResize();
  
  update();
</script>
</html>
